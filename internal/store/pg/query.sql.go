// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countQueuePosition = `-- name: CountQueuePosition :one
SELECT COUNT(*) FROM queue_entries qe
WHERE qe.repo_id = $1 AND qe.target_branch = $2
  AND qe.enqueued_at <= (SELECT qe2.enqueued_at FROM queue_entries qe2 WHERE qe2.repo_id = $1 AND qe2.pr_number = $3)
`

type CountQueuePositionParams struct {
	RepoID       int64  `json:"repo_id"`
	TargetBranch string `json:"target_branch"`
	PrNumber     int64  `json:"pr_number"`
}

func (q *Queries) CountQueuePosition(ctx context.Context, arg CountQueuePositionParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQueuePosition, arg.RepoID, arg.TargetBranch, arg.PrNumber)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const dequeuePR = `-- name: DequeuePR :exec
DELETE FROM queue_entries
WHERE repo_id = $1 AND pr_number = $2
`

type DequeuePRParams struct {
	RepoID   int64 `json:"repo_id"`
	PrNumber int64 `json:"pr_number"`
}

func (q *Queries) DequeuePR(ctx context.Context, arg DequeuePRParams) error {
	_, err := q.db.Exec(ctx, dequeuePR, arg.RepoID, arg.PrNumber)
	return err
}

const enqueuePR = `-- name: EnqueuePR :one
INSERT INTO queue_entries (repo_id, pr_number, pr_head_sha, target_branch)
VALUES ($1, $2, $3, $4)
ON CONFLICT (repo_id, pr_number) DO NOTHING
RETURNING id, repo_id, pr_number, pr_head_sha, target_branch, state, enqueued_at, testing_started_at, completed_at, merge_branch_name, merge_branch_sha, error_message
`

type EnqueuePRParams struct {
	RepoID       int64  `json:"repo_id"`
	PrNumber     int64  `json:"pr_number"`
	PrHeadSha    string `json:"pr_head_sha"`
	TargetBranch string `json:"target_branch"`
}

func (q *Queries) EnqueuePR(ctx context.Context, arg EnqueuePRParams) (QueueEntry, error) {
	row := q.db.QueryRow(ctx, enqueuePR,
		arg.RepoID,
		arg.PrNumber,
		arg.PrHeadSha,
		arg.TargetBranch,
	)
	var i QueueEntry
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.PrNumber,
		&i.PrHeadSha,
		&i.TargetBranch,
		&i.State,
		&i.EnqueuedAt,
		&i.TestingStartedAt,
		&i.CompletedAt,
		&i.MergeBranchName,
		&i.MergeBranchSha,
		&i.ErrorMessage,
	)
	return i, err
}

const getCheckStatuses = `-- name: GetCheckStatuses :many
SELECT id, queue_entry_id, context, state, updated_at FROM check_statuses
WHERE queue_entry_id = $1
`

func (q *Queries) GetCheckStatuses(ctx context.Context, queueEntryID int64) ([]CheckStatus, error) {
	rows, err := q.db.Query(ctx, getCheckStatuses, queueEntryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckStatus
	for rows.Next() {
		var i CheckStatus
		if err := rows.Scan(
			&i.ID,
			&i.QueueEntryID,
			&i.Context,
			&i.State,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeadOfQueue = `-- name: GetHeadOfQueue :one
SELECT id, repo_id, pr_number, pr_head_sha, target_branch, state, enqueued_at, testing_started_at, completed_at, merge_branch_name, merge_branch_sha, error_message FROM queue_entries
WHERE repo_id = $1 AND target_branch = $2
ORDER BY enqueued_at ASC
LIMIT 1
`

type GetHeadOfQueueParams struct {
	RepoID       int64  `json:"repo_id"`
	TargetBranch string `json:"target_branch"`
}

func (q *Queries) GetHeadOfQueue(ctx context.Context, arg GetHeadOfQueueParams) (QueueEntry, error) {
	row := q.db.QueryRow(ctx, getHeadOfQueue, arg.RepoID, arg.TargetBranch)
	var i QueueEntry
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.PrNumber,
		&i.PrHeadSha,
		&i.TargetBranch,
		&i.State,
		&i.EnqueuedAt,
		&i.TestingStartedAt,
		&i.CompletedAt,
		&i.MergeBranchName,
		&i.MergeBranchSha,
		&i.ErrorMessage,
	)
	return i, err
}

const getOrCreateRepo = `-- name: GetOrCreateRepo :one
INSERT INTO repos (owner, name)
VALUES ($1, $2)
ON CONFLICT (owner, name) DO UPDATE SET owner = EXCLUDED.owner
RETURNING id, owner, name, created_at
`

type GetOrCreateRepoParams struct {
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) GetOrCreateRepo(ctx context.Context, arg GetOrCreateRepoParams) (Repo, error) {
	row := q.db.QueryRow(ctx, getOrCreateRepo, arg.Owner, arg.Name)
	var i Repo
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const getQueueEntry = `-- name: GetQueueEntry :one
SELECT id, repo_id, pr_number, pr_head_sha, target_branch, state, enqueued_at, testing_started_at, completed_at, merge_branch_name, merge_branch_sha, error_message FROM queue_entries
WHERE repo_id = $1 AND pr_number = $2
`

type GetQueueEntryParams struct {
	RepoID   int64 `json:"repo_id"`
	PrNumber int64 `json:"pr_number"`
}

func (q *Queries) GetQueueEntry(ctx context.Context, arg GetQueueEntryParams) (QueueEntry, error) {
	row := q.db.QueryRow(ctx, getQueueEntry, arg.RepoID, arg.PrNumber)
	var i QueueEntry
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.PrNumber,
		&i.PrHeadSha,
		&i.TargetBranch,
		&i.State,
		&i.EnqueuedAt,
		&i.TestingStartedAt,
		&i.CompletedAt,
		&i.MergeBranchName,
		&i.MergeBranchSha,
		&i.ErrorMessage,
	)
	return i, err
}

const listActiveEntriesByRepo = `-- name: ListActiveEntriesByRepo :many
SELECT id, repo_id, pr_number, pr_head_sha, target_branch, state, enqueued_at, testing_started_at, completed_at, merge_branch_name, merge_branch_sha, error_message FROM queue_entries
WHERE repo_id = $1 AND state NOT IN ('failed', 'cancelled')
ORDER BY target_branch, enqueued_at ASC
`

func (q *Queries) ListActiveEntriesByRepo(ctx context.Context, repoID int64) ([]QueueEntry, error) {
	rows, err := q.db.Query(ctx, listActiveEntriesByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueueEntry
	for rows.Next() {
		var i QueueEntry
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.PrNumber,
			&i.PrHeadSha,
			&i.TargetBranch,
			&i.State,
			&i.EnqueuedAt,
			&i.TestingStartedAt,
			&i.CompletedAt,
			&i.MergeBranchName,
			&i.MergeBranchSha,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQueue = `-- name: ListQueue :many
SELECT id, repo_id, pr_number, pr_head_sha, target_branch, state, enqueued_at, testing_started_at, completed_at, merge_branch_name, merge_branch_sha, error_message FROM queue_entries
WHERE repo_id = $1 AND target_branch = $2
ORDER BY enqueued_at ASC
`

type ListQueueParams struct {
	RepoID       int64  `json:"repo_id"`
	TargetBranch string `json:"target_branch"`
}

func (q *Queries) ListQueue(ctx context.Context, arg ListQueueParams) ([]QueueEntry, error) {
	rows, err := q.db.Query(ctx, listQueue, arg.RepoID, arg.TargetBranch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueueEntry
	for rows.Next() {
		var i QueueEntry
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.PrNumber,
			&i.PrHeadSha,
			&i.TargetBranch,
			&i.State,
			&i.EnqueuedAt,
			&i.TestingStartedAt,
			&i.CompletedAt,
			&i.MergeBranchName,
			&i.MergeBranchSha,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadActiveQueues = `-- name: LoadActiveQueues :many
SELECT qe.id, qe.repo_id, qe.pr_number, qe.pr_head_sha, qe.target_branch, qe.state, qe.enqueued_at, qe.testing_started_at, qe.completed_at, qe.merge_branch_name, qe.merge_branch_sha, qe.error_message, r.owner, r.name AS repo_name
FROM queue_entries qe
JOIN repos r ON r.id = qe.repo_id
WHERE qe.state NOT IN ('failed', 'cancelled')
ORDER BY r.owner, r.name, qe.target_branch, qe.enqueued_at ASC
`

type LoadActiveQueuesRow struct {
	ID               int64              `json:"id"`
	RepoID           int64              `json:"repo_id"`
	PrNumber         int64              `json:"pr_number"`
	PrHeadSha        string             `json:"pr_head_sha"`
	TargetBranch     string             `json:"target_branch"`
	State            EntryState         `json:"state"`
	EnqueuedAt       pgtype.Timestamptz `json:"enqueued_at"`
	TestingStartedAt pgtype.Timestamptz `json:"testing_started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	MergeBranchName  pgtype.Text        `json:"merge_branch_name"`
	MergeBranchSha   pgtype.Text        `json:"merge_branch_sha"`
	ErrorMessage     pgtype.Text        `json:"error_message"`
	Owner            string             `json:"owner"`
	RepoName         string             `json:"repo_name"`
}

func (q *Queries) LoadActiveQueues(ctx context.Context) ([]LoadActiveQueuesRow, error) {
	rows, err := q.db.Query(ctx, loadActiveQueues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadActiveQueuesRow
	for rows.Next() {
		var i LoadActiveQueuesRow
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.PrNumber,
			&i.PrHeadSha,
			&i.TargetBranch,
			&i.State,
			&i.EnqueuedAt,
			&i.TestingStartedAt,
			&i.CompletedAt,
			&i.MergeBranchName,
			&i.MergeBranchSha,
			&i.ErrorMessage,
			&i.Owner,
			&i.RepoName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveCheckStatus = `-- name: SaveCheckStatus :exec
INSERT INTO check_statuses (queue_entry_id, context, state)
VALUES ($1, $2, $3)
ON CONFLICT (queue_entry_id, context) DO UPDATE
SET state = EXCLUDED.state, updated_at = NOW()
`

type SaveCheckStatusParams struct {
	QueueEntryID int64      `json:"queue_entry_id"`
	Context      string     `json:"context"`
	State        CheckState `json:"state"`
}

func (q *Queries) SaveCheckStatus(ctx context.Context, arg SaveCheckStatusParams) error {
	_, err := q.db.Exec(ctx, saveCheckStatus, arg.QueueEntryID, arg.Context, arg.State)
	return err
}

const updateEntryError = `-- name: UpdateEntryError :exec
UPDATE queue_entries
SET error_message = $3
WHERE repo_id = $1 AND pr_number = $2
`

type UpdateEntryErrorParams struct {
	RepoID       int64       `json:"repo_id"`
	PrNumber     int64       `json:"pr_number"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdateEntryError(ctx context.Context, arg UpdateEntryErrorParams) error {
	_, err := q.db.Exec(ctx, updateEntryError, arg.RepoID, arg.PrNumber, arg.ErrorMessage)
	return err
}

const updateEntryMergeBranch = `-- name: UpdateEntryMergeBranch :exec
UPDATE queue_entries
SET merge_branch_name = $3, merge_branch_sha = $4
WHERE repo_id = $1 AND pr_number = $2
`

type UpdateEntryMergeBranchParams struct {
	RepoID          int64       `json:"repo_id"`
	PrNumber        int64       `json:"pr_number"`
	MergeBranchName pgtype.Text `json:"merge_branch_name"`
	MergeBranchSha  pgtype.Text `json:"merge_branch_sha"`
}

func (q *Queries) UpdateEntryMergeBranch(ctx context.Context, arg UpdateEntryMergeBranchParams) error {
	_, err := q.db.Exec(ctx, updateEntryMergeBranch,
		arg.RepoID,
		arg.PrNumber,
		arg.MergeBranchName,
		arg.MergeBranchSha,
	)
	return err
}

const updateEntryState = `-- name: UpdateEntryState :exec
UPDATE queue_entries
SET state = $1,
    testing_started_at = CASE WHEN $1::entry_state = 'testing' THEN NOW() ELSE testing_started_at END,
    completed_at = CASE WHEN $1::entry_state IN ('success', 'failed', 'cancelled') THEN NOW() ELSE completed_at END
WHERE repo_id = $2 AND pr_number = $3
`

type UpdateEntryStateParams struct {
	State    EntryState `json:"state"`
	RepoID   int64      `json:"repo_id"`
	PrNumber int64      `json:"pr_number"`
}

func (q *Queries) UpdateEntryState(ctx context.Context, arg UpdateEntryStateParams) error {
	_, err := q.db.Exec(ctx, updateEntryState, arg.State, arg.RepoID, arg.PrNumber)
	return err
}
